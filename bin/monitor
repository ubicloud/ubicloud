#!/usr/bin/env ruby
# frozen_string_literal: true

require_relative "../loader"
clover_freeze

resources = {}
mutex = Mutex.new
thread_pool_size = (Config.max_monitor_threads - 2).clamp(1, nil)
monitorable_resource_types = [VmHost, PostgresServer, Vm.where(~Sshable.where(id: Sequel[:vm][:id]).exists), MinioServer, GithubRunner, VmHostSlice, LoadBalancerVmPort, KubernetesCluster, VictoriaMetricsServer]
queue_size = thread_pool_size + (monitorable_resource_types.sum(&:count) * 1.5).round
queue = SizedQueue.new(queue_size)

resource_scanner = Thread.new do
  loop do
    monitorable_resources = monitorable_resource_types.flat_map(&:all)
    mutex.synchronize do
      monitorable_resources.each do |r|
        resources[r.id] ||= MonitorableResource.new(r)
      end
    end

    sleep 60
  end
rescue => ex
  Clog.emit("Resource scanning has failed.") { {resource_scanning_failure: {exception: Util.exception_to_hash(ex)}} }
  ThreadPrinter.run
  Kernel.exit!
end

thread_pool = Array.new(thread_pool_size) do
  Thread.new do
    while (r = queue.pop)
      r.lock_no_wait do
        r.open_resource_session
        r.process_event_loop
        r.check_pulse
      end
    end
  end
end

begin
  loop do
    # Since the switch to use a thread pool for monitored resources,
    # this emits the number of pulse threads, not the number of monitor threads + pulse threads
    Clog.emit("Active threads count.") { {active_threads_count: Thread.list.count - thread_pool_size - 2} }

    rs = mutex.synchronize { resources.values }

    rs.each do |r|
      r.force_stop_if_stuck
      queue.push(r)
    end

    mutex.synchronize { resources.delete_if { |_, r| r.deleted } }

    sleep 5
  end
rescue => ex
  Clog.emit("Pulse checking has failed.") { {pulse_checking_failure: {exception: Util.exception_to_hash(ex)}} }
  ThreadPrinter.run
  Kernel.exit!
end

resource_scanner.join
thread_pool.each { queue.push(nil) }
thread_pool.each(&:join)
