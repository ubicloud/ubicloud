name: TLA+ Proof Check

permissions:
  contents: read

on:
  pull_request:
    paths:
    - 'proof/**'
    - 'model/metal/private_subnet.rb'
    - 'prog/vnet/metal/subnet_nexus.rb'
    - 'prog/vnet/metal/nic_nexus.rb'
    - 'model/strand.rb'
    - 'model/semaphore.rb'
    - '.github/workflows/tla.yml'
  workflow_dispatch:

env:
  TLA2TOOLS_URL: https://github.com/tlaplus/tlaplus/releases/download/v1.8.0/tla2tools.jar
  TLA2TOOLS_JAR: /usr/local/lib/tla2tools.jar
  # JVM: OffHeapDiskFPSet stores fingerprints in direct memory (off-heap),
  # eliminating GC pressure.  BAQueue reduces state queue contention for
  # many-core throughput.  ParallelGC is recommended by TLA+ docs (G1GC
  # does not work well with model checking).
  JVM_ARGS: >-
    -XX:+UseParallelGC
    -XX:+UseNUMA
    -XX:+UseTransparentHugePages
    -XX:+AlwaysPreTouch
    -Xmx16g
    -XX:MaxDirectMemorySize=90g
    -Dtlc2.tool.fp.FPSet.impl=tlc2.tool.fp.OffHeapDiskFPSet
    -Dtlc2.tool.ModelChecker.BAQueue=true

jobs:
  # ── Assemble: build proofs and check per-proof caches ────────────────
  # Each proof gets its own cache key (tlc-v3-{Name}-{sha256}).  The hash
  # covers the TLC version pin, assembled .tla, all .cfg files, and the
  # mutation-test script.  Downstream matrices are generated dynamically
  # from proof/tla.yaml, skipping any proof whose cache already hit.
  assemble:
    name: assemble
    runs-on: ubicloud
    outputs:
      assembled: ${{ steps.hash.outputs.assembled }}
      SubnetRekey-hash: ${{ steps.hash.outputs.SubnetRekey-hash }}
      StrandSchedule-hash: ${{ steps.hash.outputs.StrandSchedule-hash }}
      StrandBackoff-hash: ${{ steps.hash.outputs.StrandBackoff-hash }}
      SubnetRekey-cached: ${{ steps.cache-SubnetRekey.outputs.cache-hit }}
      StrandSchedule-cached: ${{ steps.cache-StrandSchedule.outputs.cache-hit }}
      StrandBackoff-cached: ${{ steps.cache-StrandBackoff.outputs.cache-hit }}
      safety-matrix: ${{ steps.matrix.outputs.safety-matrix }}
      liveness-matrix: ${{ steps.matrix.outputs.liveness-matrix }}
      mutation-matrix: ${{ steps.matrix.outputs.mutation-matrix }}
    steps:
    - uses: actions/checkout@v6
    - uses: ruby/setup-ruby@v1
      with:
        ruby-version: 3.4
    - name: Assemble and hash
      id: hash
      run: |
        ruby -ryaml -rdigest -rjson <<'RUBY'
        proofs = YAML.load_file("proof/tla.yaml")
        assembled = []
        proofs.each do |name, spec|
          missing = (spec["sources"] || []).reject { |s| File.exist?(s) }
          unless missing.empty?
            warn "#{name}: skipping (missing sources: #{missing.join(", ")})"
            next
          end
          system("ruby", "proof/tla", "assemble", name, exception: true)
          dir = spec["dir"]
          sha = Digest::SHA256.new
          sha.update(ENV.fetch("TLA2TOOLS_URL"))
          sha.update(File.read("#{dir}/#{name}.tla"))
          Dir["#{dir}/*.cfg"].sort.each { |f| sha.update(File.read(f)) }
          mt = "#{dir}/mutation-test"
          sha.update(File.read(mt)) if File.exist?(mt)
          assembled << name
          File.open(ENV.fetch("GITHUB_OUTPUT"), "a") do |f|
            f.puts "#{name}-hash=#{sha.hexdigest}"
          end
        end
        File.open(ENV.fetch("GITHUB_OUTPUT"), "a") do |f|
          f.puts "assembled=#{JSON.generate(assembled)}"
        end
        RUBY
    - uses: actions/cache/restore@v4
      id: cache-SubnetRekey
      if: github.event_name != 'workflow_dispatch'
      with:
        key: tlc-v3-SubnetRekey-${{ steps.hash.outputs.SubnetRekey-hash }}
        path: .tlc-pass
        lookup-only: true
    - uses: actions/cache/restore@v4
      id: cache-StrandSchedule
      if: github.event_name != 'workflow_dispatch'
      with:
        key: tlc-v3-StrandSchedule-${{ steps.hash.outputs.StrandSchedule-hash }}
        path: .tlc-pass
        lookup-only: true
    - uses: actions/cache/restore@v4
      id: cache-StrandBackoff
      if: github.event_name != 'workflow_dispatch'
      with:
        key: tlc-v3-StrandBackoff-${{ steps.hash.outputs.StrandBackoff-hash }}
        path: .tlc-pass
        lookup-only: true
    - name: Build matrices
      id: matrix
      env:
        ASSEMBLED: ${{ steps.hash.outputs.assembled }}
        CACHED_SubnetRekey: ${{ steps.cache-SubnetRekey.outputs.cache-hit }}
        CACHED_StrandSchedule: ${{ steps.cache-StrandSchedule.outputs.cache-hit }}
        CACHED_StrandBackoff: ${{ steps.cache-StrandBackoff.outputs.cache-hit }}
      run: |
        ruby -ryaml -rjson <<'RUBY'
        proofs = YAML.load_file("proof/tla.yaml")
        assembled = JSON.parse(ENV.fetch("ASSEMBLED", "[]"))
        safety = []
        liveness = []
        mutation = []

        proofs.each do |name, spec|
          next unless assembled.include?(name)
          next if ENV["CACHED_#{name}"] == "true"
          dir = spec["dir"]
          configs = spec["configs"] || {}

          # Base config -> safety
          safety << {"proof" => name, "config" => ""}

          configs.each do |config_name, _|
            entry = {"proof" => name, "config" => config_name}
            if config_name == "liveness"
              liveness << entry
            else
              safety << entry
            end
          end

          # Mutation test
          mutation << {"proof" => name, "dir" => dir} if File.exist?("#{dir}/mutation-test")
        end

        File.open(ENV.fetch("GITHUB_OUTPUT"), "a") do |f|
          f.puts "safety-matrix=#{JSON.generate(safety)}"
          f.puts "liveness-matrix=#{JSON.generate(liveness)}"
          f.puts "mutation-matrix=#{JSON.generate(mutation)}"
        end
        RUBY

  # ── Safety: invariant checking across depth and breadth ───────────────
  #
  # SubnetRekey configs (generated from tla.yaml):
  #   base         default topology verification
  #   2s4n  2S/4N  MaxOps=60 — long histories, NIC thrashing
  #   3s5n  3S/5N  MaxOps=12 — transitive connectivity, 3-way contention
  #   3s6n  3S/6N  intermediate topology
  #   3s9n  3S/9N  MaxOps=6  — many NICs per subnet, 3-way barrier stress
  #   4s8n  4S/8N  MaxOps=5  — 4-way contention, uniform 2 NICs/subnet
  #   5s8n  5S/8N  MaxOps=4  — 5-way contention, full chain coverage
  #   6s4n  6S/4N  MaxOps=2  — wide topology, few NICs, leader forwarding
  #   8s10n 8S/10N MaxOps=3  — wide topology stress test
  #
  # StrandSchedule, StrandBackoff: base config only (plus signal for Backoff)
  safety:
    name: "safety · ${{ matrix.proof }} · ${{ matrix.config || 'base' }}"
    needs: assemble
    if: needs.assemble.outputs.safety-matrix != '[]'
    runs-on: ubicloud-standard-30
    timeout-minutes: 60
    strategy:
      fail-fast: false
      matrix:
        include: ${{ fromJSON(needs.assemble.outputs.safety-matrix) }}
    steps:
    - uses: actions/checkout@v6
    - uses: actions/setup-java@v4
      with:
        distribution: temurin
        java-version: 21
    - name: Install tla2tools
      run: |
        sudo wget -nv -O $TLA2TOOLS_JAR "$TLA2TOOLS_URL"
        printf '#!/bin/sh\nexec java %s -cp %s tlc2.TLC -workers 28 -fpmem 0.9 "$@"\n' \
          "$JVM_ARGS" "$TLA2TOOLS_JAR" | sudo tee /usr/local/bin/tlc > /dev/null
        sudo chmod +x /usr/local/bin/tlc
    - uses: ruby/setup-ruby@v1
      with:
        ruby-version: 3.4
    - name: Run TLC
      run: |
        if [ -n "${{ matrix.config }}" ]; then
          ruby proof/tla check -c "${{ matrix.config }}" "${{ matrix.proof }}"
        else
          ruby proof/tla check "${{ matrix.proof }}"
        fi

  # ── Liveness: temporal property checking ──────────────────────────────
  liveness:
    name: "liveness · ${{ matrix.proof }}"
    needs: assemble
    if: needs.assemble.outputs.liveness-matrix != '[]'
    runs-on: ubicloud-standard-30
    timeout-minutes: 360
    strategy:
      fail-fast: false
      matrix:
        include: ${{ fromJSON(needs.assemble.outputs.liveness-matrix) }}
    steps:
    - uses: actions/checkout@v6
    - uses: actions/setup-java@v4
      with:
        distribution: temurin
        java-version: 21
    - name: Install tla2tools
      run: |
        sudo wget -nv -O $TLA2TOOLS_JAR "$TLA2TOOLS_URL"
        printf '#!/bin/sh\nexec java %s -cp %s tlc2.TLC -workers 28 -fpmem 0.9 "$@"\n' \
          "$JVM_ARGS" "$TLA2TOOLS_JAR" | sudo tee /usr/local/bin/tlc > /dev/null
        sudo chmod +x /usr/local/bin/tlc
    - uses: ruby/setup-ruby@v1
      with:
        ruby-version: 3.4
    - name: Run TLC
      run: ruby proof/tla check -c liveness "${{ matrix.proof }}"

  # ── Mutation testing: invariant sensitivity ───────────────────────────
  mutation-test:
    name: "mutation · ${{ matrix.proof }}"
    needs: assemble
    if: needs.assemble.outputs.mutation-matrix != '[]'
    runs-on: ubicloud-standard-30
    timeout-minutes: 30
    strategy:
      fail-fast: false
      matrix:
        include: ${{ fromJSON(needs.assemble.outputs.mutation-matrix) }}
    steps:
    - uses: actions/checkout@v6
    - uses: actions/setup-java@v4
      with:
        distribution: temurin
        java-version: 21
    - name: Install tla2tools
      run: |
        sudo wget -nv -O $TLA2TOOLS_JAR "$TLA2TOOLS_URL"
        printf '#!/bin/sh\nexec java %s -cp %s tlc2.TLC -workers 28 -fpmem 0.9 "$@"\n' \
          "$JVM_ARGS" "$TLA2TOOLS_JAR" | sudo tee /usr/local/bin/tlc > /dev/null
        sudo chmod +x /usr/local/bin/tlc
    - uses: ruby/setup-ruby@v1
      with:
        ruby-version: 3.4
    - name: Run mutation tests
      run: ruby ${{ matrix.dir }}/mutation-test

  # ── Proof tool specs ──────────────────────────────────────────────────
  proof-tool-spec:
    name: proof-tool specs
    runs-on: ubicloud
    timeout-minutes: 10
    steps:
    - uses: actions/checkout@v6
    - uses: ruby/setup-ruby@v1
      with:
        ruby-version: 3.4
        bundler-cache: true
      env:
        BUNDLE_GEMFILE: proof/Gemfile
    - name: Run specs
      run: cd proof && bundle exec rspec spec

  # ── Finalize: save per-proof caches on success ────────────────────────
  finalize:
    name: save cache
    needs: [assemble, safety, liveness, mutation-test]
    if: >-
      always() &&
      !contains(needs.*.result, 'failure') &&
      !contains(needs.*.result, 'cancelled')
    runs-on: ubicloud
    steps:
    - run: mkdir -p .tlc-pass && touch .tlc-pass/done
    - uses: actions/cache/save@v4
      if: >-
        contains(fromJSON(needs.assemble.outputs.assembled), 'SubnetRekey') &&
        needs.assemble.outputs.SubnetRekey-cached != 'true'
      with:
        key: tlc-v3-SubnetRekey-${{ needs.assemble.outputs.SubnetRekey-hash }}
        path: .tlc-pass
    - uses: actions/cache/save@v4
      if: >-
        contains(fromJSON(needs.assemble.outputs.assembled), 'StrandSchedule') &&
        needs.assemble.outputs.StrandSchedule-cached != 'true'
      with:
        key: tlc-v3-StrandSchedule-${{ needs.assemble.outputs.StrandSchedule-hash }}
        path: .tlc-pass
    - uses: actions/cache/save@v4
      if: >-
        contains(fromJSON(needs.assemble.outputs.assembled), 'StrandBackoff') &&
        needs.assemble.outputs.StrandBackoff-cached != 'true'
      with:
        key: tlc-v3-StrandBackoff-${{ needs.assemble.outputs.StrandBackoff-hash }}
        path: .tlc-pass
