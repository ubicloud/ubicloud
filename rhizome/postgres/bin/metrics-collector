#!/usr/bin/env ruby

# frozen_string_literal: true

require "fileutils"
require "json"
require "net/http"
require "openssl"
require "time"
require "uri"

if ARGV.count != 1
  fail "Wrong number of arguments. Expected 1, Given #{ARGV.count}"
end

metrics_dir = ARGV[0]
fail "Metrics directory does not exist: #{metrics_dir}" unless Dir.exist?(metrics_dir)

fail "Metrics config file does not exist: #{metrics_dir}/config.json" unless File.exist?("#{metrics_dir}/config.json")

# Create directories
FileUtils.mkdir_p("#{metrics_dir}/pending")
FileUtils.mkdir_p("#{metrics_dir}/done")

# Parse config
metrics_config_hash = JSON.parse(File.read("#{metrics_dir}/config.json"))
endpoints = metrics_config_hash["endpoints"]
max_pending_buffer_size = metrics_config_hash["max_pending_buffer_size"] || 100

filename = Time.now.utc.strftime("%Y-%m-%dT%H-%M-%S-%6N")
temp_file_path = "/tmp/#{filename}.txt"

# Collect metrics from each endpoint using Ruby's HTTP client
File.open(temp_file_path, "w") do |file|
  endpoints.each do |endpoint|
    uri = URI(endpoint)
    http = Net::HTTP.new(uri.host, uri.port)
    http.use_ssl = uri.scheme == "https"
    http.verify_mode = OpenSSL::SSL::VERIFY_NONE # Equivalent to --insecure

    response = http.get(uri.request_uri)
    fail "HTTP request failed with status: #{response.code}" unless response.is_a?(Net::HTTPSuccess)
    file.write(response.body)
  end
end

# Move file to pending directory
File.rename(temp_file_path, "#{metrics_dir}/pending/#{filename}.txt")

# Remove pending files till the number of files is less than
# max_pending_buffer_size.
pending_files = Dir.children("#{metrics_dir}/pending").sort
num_files_to_remove = [pending_files.count - max_pending_buffer_size, 0].max

pending_files.slice(0, num_files_to_remove).each do |pending_file|
  File.rename("#{metrics_dir}/pending/#{pending_file}", "#{metrics_dir}/done/#{pending_file}")
end

# Delete all done files.
Dir.children("#{metrics_dir}/done").each do |done_file|
  File.delete("#{metrics_dir}/done/#{done_file}")
end
