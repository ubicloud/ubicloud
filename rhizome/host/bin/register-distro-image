#!/bin/env ruby
# frozen_string_literal: true

# Downloads a distro image from a URL, converts it to raw if needed,
# initializes ubiblk metadata, and archives it to R2.
#
# Reads JSON params from stdin:
#   url             - URL of the image to download
#   sha256          - Expected SHA-256 checksum of the downloaded file
#   work_dir        - Temporary working directory on the host
#   archive_bin     - Path to the ubiblk archive binary
#   init_metadata_bin - Path to the ubiblk init-metadata binary
#   target_config_content - TOML content for the archive target (S3/R2)
#   s3_key_id       - S3 access key ID
#   s3_secret_key   - S3 secret access key

require "json"
require "fileutils"
require_relative "../../common/lib/util"

params = JSON.parse($stdin.read)

url = params.fetch("url")
expected_sha256 = params.fetch("sha256")
work_dir = params.fetch("work_dir")
archive_bin = params.fetch("archive_bin")
init_metadata_bin = params.fetch("init_metadata_bin")
target_config_content = params.fetch("target_config_content")
s3_key_id = params.fetch("s3_key_id")
s3_secret_key = params.fetch("s3_secret_key")

FileUtils.mkdir_p(work_dir)

downloaded_path = File.join(work_dir, "image.download")
raw_path = File.join(work_dir, "image.raw")
metadata_path = File.join(work_dir, "metadata")
device_config_path = File.join(work_dir, "device.toml")
target_config_path = File.join(work_dir, "target.toml")
secrets_dir = File.join(work_dir, "secrets")

begin
  # Step 1: Download the image
  $stderr.puts "Downloading image from #{url}..."
  actual_sha256 = curl_file(url, downloaded_path)
  fail "SHA-256 mismatch: expected #{expected_sha256}, got #{actual_sha256}" unless actual_sha256 == expected_sha256

  # Step 2: Detect format and convert to raw if needed
  format_output = r("qemu-img", "info", "--output=json", downloaded_path)
  format_info = JSON.parse(format_output)
  image_format = format_info["format"]

  if image_format == "raw"
    FileUtils.mv(downloaded_path, raw_path)
  else
    $stderr.puts "Converting #{image_format} to raw..."
    r "qemu-img", "convert", "-f", image_format, "-O", "raw", downloaded_path, raw_path
    FileUtils.rm_f(downloaded_path)
  end

  # Get image size
  image_size = File.size(raw_path)
  $stderr.puts "Raw image size: #{image_size} bytes (#{(image_size / (1024.0**3)).round(2)} GiB)"

  # Step 3: Create a minimal device config for init-metadata and archive
  # The stripe_source points to the raw image so init-metadata marks all
  # stripes as HAS_SOURCE. The archive binary then reads from stripe_source.
  device_config = <<~TOML
    [device]
    data_path = #{raw_path.inspect}
    metadata_path = #{metadata_path.inspect}
    device_id = "distro-register"

    [tuning]
    num_queues = 1
    queue_size = 64
    io_engine = "sync"

    [stripe_source]
    type = "raw"
    image_path = #{raw_path.inspect}
    autofetch = false
    copy_on_read = false

    [danger_zone]
    enabled = true
    allow_unencrypted_disk = true
    allow_inline_plaintext_secrets = false
    allow_secret_over_regular_file = true
    allow_unencrypted_connection = true
    allow_env_secrets = false
  TOML
  safe_write_to_file(device_config_path, device_config)

  # Step 4: Initialize metadata -- marks all stripes as HAS_SOURCE
  $stderr.puts "Initializing metadata..."
  r init_metadata_bin, "-f", device_config_path, "--stripe-sector-count-shift", "11"

  # Step 5: Write target config and set up secret pipes
  safe_write_to_file(target_config_path, target_config_content)

  FileUtils.mkdir_p(secrets_dir)

  pipe_threads = []

  s3_key_id_pipe = File.join(secrets_dir, "s3-key-id.pipe")
  FileUtils.rm_f(s3_key_id_pipe)
  r "mkfifo -m 0600 #{s3_key_id_pipe}"
  pipe_threads << Thread.new { File.write(s3_key_id_pipe, s3_key_id) }

  s3_secret_key_pipe = File.join(secrets_dir, "s3-secret-key.pipe")
  FileUtils.rm_f(s3_secret_key_pipe)
  r "mkfifo -m 0600 #{s3_secret_key_pipe}"
  pipe_threads << Thread.new { File.write(s3_secret_key_pipe, s3_secret_key) }

  # Step 6: Run archive
  $stderr.puts "Archiving to R2..."
  r "#{archive_bin} -f #{device_config_path} --target-config #{target_config_path} --compression zstd --zstd-level 3"

  $stderr.puts "Archive complete."
  pipe_threads.each { |t| t.join(5) }

  # Output image size in GiB (ceiling) for the caller
  size_gib = (image_size / (1024.0**3)).ceil
  puts size_gib.to_s
ensure
  # Clean up all temp files
  FileUtils.rm_f(downloaded_path)
  FileUtils.rm_f(raw_path)
  FileUtils.rm_f(metadata_path)
  FileUtils.rm_f(device_config_path)
  FileUtils.rm_f(target_config_path)
  FileUtils.rm_rf(secrets_dir)
end
